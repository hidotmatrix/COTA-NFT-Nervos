"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const isTxPoolIds = (rawTxPool) => {
    return Array.isArray(rawTxPool.pending);
};
const toNumber = (number) => number.toString();
const toHash = (hash) => hash;
const toHeader = (header) => {
    if (!header)
        return header;
    const { compact_target: compactTarget, transactions_root: transactionsRoot, proposals_hash: proposalsHash, extra_hash: extraHash, parent_hash: parentHash } = header, rest = (0, tslib_1.__rest)(header, ["compact_target", "transactions_root", "proposals_hash", "extra_hash", "parent_hash"]);
    return Object.assign({ compactTarget,
        parentHash,
        transactionsRoot,
        proposalsHash,
        extraHash }, rest);
};
const toScript = (script) => {
    if (!script)
        return script;
    const { code_hash: codeHash, hash_type: hashType } = script, rest = (0, tslib_1.__rest)(script, ["code_hash", "hash_type"]);
    return Object.assign({ codeHash,
        hashType }, rest);
};
const toInput = (input) => {
    if (!input)
        return input;
    const { previous_output: previousOutput } = input, rest = (0, tslib_1.__rest)(input, ["previous_output"]);
    return Object.assign({ previousOutput: previousOutput ? toOutPoint(previousOutput) : previousOutput }, rest);
};
const toOutput = (output) => {
    if (!output)
        return output;
    const { lock, type } = output, rest = (0, tslib_1.__rest)(output, ["lock", "type"]);
    return Object.assign({ lock: toScript(lock), type: type ? toScript(type) : type }, rest);
};
const toOutPoint = (outPoint) => {
    if (!outPoint)
        return outPoint;
    const { tx_hash: txHash } = outPoint, rest = (0, tslib_1.__rest)(outPoint, ["tx_hash"]);
    return Object.assign({ txHash }, rest);
};
const toDepType = (type) => {
    if (type === 'dep_group') {
        return 'depGroup';
    }
    return type;
};
const toCellDep = (cellDep) => {
    if (!cellDep)
        return cellDep;
    const { out_point: outPoint = null, dep_type = 'code' } = cellDep, rest = (0, tslib_1.__rest)(cellDep, ["out_point", "dep_type"]);
    return Object.assign({ outPoint: toOutPoint(outPoint), depType: toDepType(dep_type) }, rest);
};
function toTransaction(tx) {
    if (!tx)
        return tx;
    const { cell_deps: cellDeps = [], inputs = [], outputs = [], outputs_data: outputsData = [], header_deps: headerDeps = [] } = tx, rest = (0, tslib_1.__rest)(tx, ["cell_deps", "inputs", "outputs", "outputs_data", "header_deps"]);
    return Object.assign({ cellDeps: cellDeps.map(toCellDep), inputs: inputs.map(toInput), outputs: outputs.map(toOutput), outputsData,
        headerDeps }, rest);
}
const toUncleBlock = (uncleBlock) => {
    if (!uncleBlock)
        return uncleBlock;
    const { header } = uncleBlock, rest = (0, tslib_1.__rest)(uncleBlock, ["header"]);
    return Object.assign({ header: toHeader(header) }, rest);
};
const toBlock = (block) => {
    if (!block)
        return block;
    const { header, uncles = [], transactions = [] } = block, rest = (0, tslib_1.__rest)(block, ["header", "uncles", "transactions"]);
    return Object.assign({ header: toHeader(header), uncles: uncles.map(toUncleBlock), transactions: transactions.map(toTransaction) }, rest);
};
const toAlertMessage = (alertMessage) => {
    if (!alertMessage)
        return alertMessage;
    const { notice_until: noticeUntil } = alertMessage, rest = (0, tslib_1.__rest)(alertMessage, ["notice_until"]);
    return Object.assign({ noticeUntil }, rest);
};
const toBlockchainInfo = (info) => {
    if (!info)
        return info;
    const { is_initial_block_download: isInitialBlockDownload, median_time: medianTime, alerts } = info, rest = (0, tslib_1.__rest)(info, ["is_initial_block_download", "median_time", "alerts"]);
    return Object.assign({ isInitialBlockDownload,
        medianTime, alerts: alerts.map(toAlertMessage) }, rest);
};
const toLocalNodeInfo = (info) => {
    if (!info)
        return info;
    const { node_id: nodeId, protocols } = info, rest = (0, tslib_1.__rest)(info, ["node_id", "protocols"]);
    return Object.assign({ nodeId, protocols: protocols.map(({ id, name, support_versions: supportVersions }) => ({ id, name, supportVersions })) }, rest);
};
const toRemoteNodeInfo = (info) => {
    if (!info)
        return info;
    const { node_id: nodeId, connected_duration: connectedDuration, is_outbound: isOutbound, last_ping_duration: lastPingDuration, sync_state } = info, rest = (0, tslib_1.__rest)(info, ["node_id", "connected_duration", "is_outbound", "last_ping_duration", "sync_state"]);
    return Object.assign({ nodeId,
        connectedDuration,
        isOutbound,
        lastPingDuration, syncState: {
            bestKnownHeaderHash: sync_state.best_known_header_hash,
            bestKnownHeaderNumber: sync_state.best_known_header_number,
            canFetchCount: sync_state.can_fetch_count,
            inflightCount: sync_state.inflight_count,
            lastCommonHeaderHash: sync_state.last_common_header_hash,
            lastCommonHeaderNumber: sync_state.last_common_header_number,
            unknownHeaderListSize: sync_state.unknown_header_list_size,
        } }, rest);
};
const toTxPoolInfo = (info) => {
    if (!info)
        return info;
    const { last_txs_updated_at: lastTxsUpdatedAt, tip_hash: tipHash, tip_number: tipNumber, total_tx_cycles: totalTxCycles, total_tx_size: totalTxSize, min_fee_rate: minFeeRate } = info, rest = (0, tslib_1.__rest)(info, ["last_txs_updated_at", "tip_hash", "tip_number", "total_tx_cycles", "total_tx_size", "min_fee_rate"]);
    return Object.assign({ lastTxsUpdatedAt,
        tipHash,
        tipNumber,
        totalTxCycles,
        totalTxSize,
        minFeeRate }, rest);
};
const toPeers = (nodes) => {
    if (!Array.isArray(nodes))
        return [];
    return nodes.map(toRemoteNodeInfo);
};
const toCell = (cell) => {
    if (!cell)
        return cell;
    const { lock, type } = cell, rest = (0, tslib_1.__rest)(cell, ["lock", "type"]);
    return Object.assign({ lock: toScript(lock), type: type ? toScript(type) : null }, rest);
};
const toLiveCell = (liveCell) => {
    if (!liveCell)
        return liveCell;
    const { data, output } = liveCell, rest = (0, tslib_1.__rest)(liveCell, ["data", "output"]);
    return Object.assign({ data, output: toOutput(output) }, rest);
};
const toLiveCellWithStatus = (cellWithStatus) => {
    if (!cellWithStatus)
        return cellWithStatus;
    const { cell } = cellWithStatus, rest = (0, tslib_1.__rest)(cellWithStatus, ["cell"]);
    return Object.assign({ cell: toLiveCell(cell) }, rest);
};
const toCells = (cells) => {
    if (!Array.isArray(cells))
        return [];
    return cells.map(toCell);
};
const toCellIncludingOutPoint = (cell) => {
    if (!cell)
        return cell;
    const { lock, block_hash: blockHash, out_point, output_data_len: outputDataLen } = cell, rest = (0, tslib_1.__rest)(cell, ["lock", "block_hash", "out_point", "output_data_len"]);
    return Object.assign({ blockHash, lock: toScript(lock), outPoint: toOutPoint(out_point), outputDataLen }, rest);
};
const toCellsIncludingOutPoint = (cells) => {
    if (!Array.isArray(cells))
        return [];
    return cells.map(toCellIncludingOutPoint);
};
const toTransactionWithStatus = (txWithStatus) => {
    if (!txWithStatus)
        return txWithStatus;
    const { transaction, tx_status: { block_hash: blockHash, status } } = txWithStatus, rest = (0, tslib_1.__rest)(txWithStatus, ["transaction", "tx_status"]);
    return Object.assign({ transaction: toTransaction(transaction), txStatus: {
            blockHash,
            status,
        } }, rest);
};
const toEpoch = (epoch) => {
    if (!epoch)
        return epoch;
    const { start_number: startNumber, compact_target: compactTarget } = epoch, rest = (0, tslib_1.__rest)(epoch, ["start_number", "compact_target"]);
    return Object.assign({ compactTarget,
        startNumber }, rest);
};
const toTransactionPoint = (transactionPoint) => {
    if (!transactionPoint)
        return transactionPoint;
    const { block_number: blockNumber, tx_hash: txHash } = transactionPoint, rest = (0, tslib_1.__rest)(transactionPoint, ["block_number", "tx_hash"]);
    return Object.assign({ blockNumber,
        txHash }, rest);
};
const toTransactionsByLockHash = (transactions) => {
    if (!transactions)
        return transactions;
    return transactions.map(tx => ({
        consumedBy: tx.consumed_by ? toTransactionPoint(tx.consumed_by) : tx.consumed_by,
        createdBy: toTransactionPoint(tx.created_by),
    }));
};
const toLiveCellsByLockHash = (cells) => {
    if (!cells)
        return cells;
    return cells.map(cell => ({
        cellOutput: toCell(cell.cell_output),
        createdBy: toTransactionPoint(cell.created_by),
        cellbase: cell.cellbase,
        outputDataLen: cell.output_data_len,
    }));
};
const toLockHashIndexState = (index) => {
    if (!index)
        return index;
    const { block_hash: blockHash, block_number: blockNumber, lock_hash: lockHash } = index, rest = (0, tslib_1.__rest)(index, ["block_hash", "block_number", "lock_hash"]);
    return Object.assign({ blockHash,
        blockNumber,
        lockHash }, rest);
};
const toLockHashIndexStates = (states) => {
    if (!states)
        return states;
    return states.map(toLockHashIndexState);
};
const toBannedAddress = (bannedAddress) => {
    if (!bannedAddress)
        return bannedAddress;
    const { ban_reason: banReason, ban_until: banUntil, created_at: createdAt } = bannedAddress, rest = (0, tslib_1.__rest)(bannedAddress, ["ban_reason", "ban_until", "created_at"]);
    return Object.assign({ banReason,
        banUntil,
        createdAt }, rest);
};
const toBannedAddresses = (bannedAddresses) => {
    if (!bannedAddresses)
        return bannedAddresses;
    return bannedAddresses.map(banAddr => toBannedAddress(banAddr));
};
const toCellbaseOutputCapacityDetails = (details) => {
    if (!details)
        return details;
    const { proposal_reward: proposalReward, tx_fee: txFee } = details, rest = (0, tslib_1.__rest)(details, ["proposal_reward", "tx_fee"]);
    return Object.assign({ proposalReward,
        txFee }, rest);
};
const toFeeRate = (feeRateObj) => {
    if (!feeRateObj) {
        return feeRateObj;
    }
    const { fee_rate: feeRate } = feeRateObj, rest = (0, tslib_1.__rest)(feeRateObj, ["fee_rate"]);
    return Object.assign({ feeRate }, rest);
};
const toCapacityByLockHash = (capacityByLockHash) => {
    if (!capacityByLockHash) {
        return capacityByLockHash;
    }
    const { cells_count: cellsCount, block_number: blockNumber, capacity } = capacityByLockHash, rest = (0, tslib_1.__rest)(capacityByLockHash, ["cells_count", "block_number", "capacity"]);
    return Object.assign({ blockNumber,
        capacity,
        cellsCount }, rest);
};
const toBlockEconomicState = (blockEconomicState) => {
    if (!blockEconomicState) {
        return blockEconomicState;
    }
    const { finalized_at: finalizedAt, miner_reward: minerReward, txs_fee: txsFee } = blockEconomicState, rest = (0, tslib_1.__rest)(blockEconomicState, ["finalized_at", "miner_reward", "txs_fee"]);
    return Object.assign({ finalizedAt,
        minerReward,
        txsFee }, rest);
};
const toSyncState = (state) => {
    if (!state) {
        return state;
    }
    return {
        bestKnownBlockNumber: state.best_known_block_number,
        bestKnownBlockTimestamp: state.best_known_block_timestamp,
        fastTime: state.fast_time,
        ibd: state.ibd,
        inflightBlocksCount: state.inflight_blocks_count,
        lowTime: state.low_time,
        normalTime: state.normal_time,
        orphanBlocksCount: state.orphan_blocks_count,
    };
};
const toTransactionProof = (proof) => {
    if (!proof) {
        return proof;
    }
    const { block_hash: blockHash, witnesses_root: witnessesRoot } = proof, rest = (0, tslib_1.__rest)(proof, ["block_hash", "witnesses_root"]);
    return Object.assign({ blockHash,
        witnessesRoot }, rest);
};
const toConsensus = (consensus) => {
    var _a, _b;
    if (!consensus)
        return consensus;
    return {
        blockVersion: consensus.block_version,
        cellbaseMaturity: consensus.cellbase_maturity,
        daoTypeHash: consensus.dao_type_hash,
        epochDurationTarget: consensus.epoch_duration_target,
        genesisHash: consensus.genesis_hash,
        id: consensus.id,
        initialPrimaryEpochReward: consensus.initial_primary_epoch_reward,
        maxBlockBytes: consensus.max_block_bytes,
        maxBlockCycles: consensus.max_block_cycles,
        maxBlockProposalsLimit: consensus.max_block_proposals_limit,
        maxUnclesNum: consensus.max_uncles_num,
        medianTimeBlockCount: consensus.median_time_block_count,
        orphanRateTarget: consensus.orphan_rate_target,
        permanentDifficultyInDummy: consensus.permanent_difficulty_in_dummy,
        primaryEpochRewardHalvingInterval: consensus.primary_epoch_reward_halving_interval,
        proposerRewardRatio: consensus.proposer_reward_ratio,
        secondaryEpochReward: consensus.secondary_epoch_reward,
        secp256k1Blake160MultisigAllTypeHash: consensus.secp256k1_blake160_multisig_all_type_hash,
        secp256k1Blake160SighashAllTypeHash: consensus.secp256k1_blake160_sighash_all_type_hash,
        txProposalWindow: consensus.tx_proposal_window,
        txVersion: consensus.tx_version,
        typeIdCodeHash: consensus.type_id_code_hash,
        hardforkFeatures: (_b = (_a = consensus.hardfork_features) === null || _a === void 0 ? void 0 : _a.map((_a) => {
            var { epoch_number: epochNumber } = _a, rest = (0, tslib_1.__rest)(_a, ["epoch_number"]);
            return (Object.assign({ epochNumber }, rest));
        })) !== null && _b !== void 0 ? _b : consensus.hardfork_features,
    };
};
const toRawTxPool = (rawTxPool) => {
    if (!rawTxPool)
        return rawTxPool;
    if (isTxPoolIds(rawTxPool)) {
        return rawTxPool;
    }
    const toTxVerbosity = (_a) => {
        var { ancestors_count: ancestorsCount, ancestors_cycles: ancestorsCycles, ancestors_size: ancestorsSize } = _a, rest = (0, tslib_1.__rest)(_a, ["ancestors_count", "ancestors_cycles", "ancestors_size"]);
        return (Object.assign({ ancestorsCount,
            ancestorsCycles,
            ancestorsSize }, rest));
    };
    const proposed = {};
    const pending = {};
    Object.keys(rawTxPool.proposed).forEach(hash => {
        proposed[hash] = toTxVerbosity(rawTxPool.proposed[hash]);
    });
    Object.keys(rawTxPool.pending).forEach(hash => {
        pending[hash] = toTxVerbosity(rawTxPool.pending[hash]);
    });
    return { proposed, pending };
};
exports.default = {
    toNumber,
    toHash,
    toHeader,
    toScript,
    toInput,
    toOutput,
    toOutPoint,
    toDepType,
    toCellDep,
    toTransaction,
    toUncleBlock,
    toBlock,
    toAlertMessage,
    toBlockchainInfo,
    toLocalNodeInfo,
    toRemoteNodeInfo,
    toTxPoolInfo,
    toPeers,
    toLiveCell,
    toLiveCellWithStatus,
    toCell,
    toCells,
    toCellIncludingOutPoint,
    toCellsIncludingOutPoint,
    toTransactionWithStatus,
    toEpoch,
    toTransactionPoint,
    toTransactionsByLockHash,
    toLiveCellsByLockHash,
    toLockHashIndexState,
    toLockHashIndexStates,
    toBannedAddress,
    toBannedAddresses,
    toCellbaseOutputCapacityDetails,
    toFeeRate,
    toCapacityByLockHash,
    toBlockEconomicState,
    toSyncState,
    toTransactionProof,
    toConsensus,
    toRawTxPool,
};
//# sourceMappingURL=resultFormatter.js.map