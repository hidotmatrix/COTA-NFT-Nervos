"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLeftCells = exports.getInputs = exports.getTargetOutputs = exports.getKeyAndCellsPairs = exports.getBigInts = void 0;
const tslib_1 = require("tslib");
const ckb_sdk_utils_1 = require("@nervosnetwork/ckb-sdk-utils");
const const_1 = require("@nervosnetwork/ckb-sdk-utils/lib/const");
const validators_1 = require("@nervosnetwork/ckb-sdk-utils/lib/validators");
const EMPTY_DATA = '0x';
const MIN_CELL_CAPACITY = `0x${(6100000000).toString(16)}`;
const getBigInts = ({ fee, capacityThreshold, changeThreshold }) => {
    (0, validators_1.assertToBeHexStringOrBigint)(fee);
    (0, validators_1.assertToBeHexStringOrBigint)(capacityThreshold);
    (0, validators_1.assertToBeHexStringOrBigint)(changeThreshold);
    return {
        targetFee: ckb_sdk_utils_1.JSBI.BigInt(`${fee}`),
        minCapacity: ckb_sdk_utils_1.JSBI.BigInt(`${capacityThreshold}`),
        minChange: ckb_sdk_utils_1.JSBI.BigInt(`${changeThreshold}`),
        zeroBigInt: ckb_sdk_utils_1.JSBI.BigInt(0),
    };
};
exports.getBigInts = getBigInts;
const getKeyAndCellsPairs = (params) => {
    const inputScripts = 'inputScript' in params ? [params.inputScript] : params.inputScripts;
    const outputs = 'outputScript' in params ? [{ lock: params.outputScript, capacity: params.capacity }] : params.outputs;
    let unspentCellsMap = new Map();
    if ('inputScript' in params) {
        const lockHash = (0, ckb_sdk_utils_1.scriptToHash)(params.inputScript);
        unspentCellsMap.set(lockHash, params.cells || []);
    }
    else {
        unspentCellsMap = params.cells || new Map();
    }
    return { inputScripts, outputs, unspentCellsMap };
};
exports.getKeyAndCellsPairs = getKeyAndCellsPairs;
const getTargetOutputs = ({ outputs, minCapacity, }) => {
    return outputs.map(output => {
        const capacity = ckb_sdk_utils_1.JSBI.BigInt(`${output.capacity}`);
        if (ckb_sdk_utils_1.JSBI.lessThan(capacity, minCapacity)) {
            throw new Error(`Capacity should be at least ${minCapacity} shannon`);
        }
        return Object.assign(Object.assign({}, output), { capacity });
    });
};
exports.getTargetOutputs = getTargetOutputs;
const getInputs = ({ inputScripts, safeMode, costCapacity, unspentCellsMap, }) => {
    const inputs = [];
    let sum = ckb_sdk_utils_1.JSBI.BigInt(0);
    for (let i = 0; i < inputScripts.length; i++) {
        const lockhash = (0, ckb_sdk_utils_1.scriptToHash)(inputScripts[i]);
        const unspentCells = unspentCellsMap.get(lockhash) || [];
        for (let j = 0; j < unspentCells.length; j++) {
            const c = unspentCells[j];
            if (!safeMode || (c.data === EMPTY_DATA && !c.type)) {
                inputs.push({ previousOutput: c.outPoint, since: '0x0', lockhash });
                sum = ckb_sdk_utils_1.JSBI.add(sum, ckb_sdk_utils_1.JSBI.BigInt(c.capacity));
                if (ckb_sdk_utils_1.JSBI.greaterThanOrEqual(sum, costCapacity)) {
                    break;
                }
            }
        }
        if (ckb_sdk_utils_1.JSBI.greaterThan(sum, costCapacity)) {
            break;
        }
    }
    if (ckb_sdk_utils_1.JSBI.lessThan(sum, costCapacity)) {
        throw new Error('Input capacity is not enough');
    }
    return { inputs, sum };
};
exports.getInputs = getInputs;
const getLeftCells = ({ usedCells, inputScripts, unspentCellsMap, }) => {
    const leftCells = [];
    const isCellUsed = (cell) => usedCells.some(used => { var _a, _b, _c, _d; return ((_a = used.previousOutput) === null || _a === void 0 ? void 0 : _a.txHash) === ((_b = cell.outPoint) === null || _b === void 0 ? void 0 : _b.txHash) && ((_c = used.previousOutput) === null || _c === void 0 ? void 0 : _c.index) === ((_d = cell.outPoint) === null || _d === void 0 ? void 0 : _d.index); });
    inputScripts.forEach(script => {
        const lockhash = (0, ckb_sdk_utils_1.scriptToHash)(script);
        const cells = unspentCellsMap.get(lockhash);
        if (cells === null || cells === void 0 ? void 0 : cells.length) {
            cells.forEach(cell => {
                if (cell.data === EMPTY_DATA && !cell.type && !isCellUsed(cell)) {
                    leftCells.push({
                        outPoint: cell.outPoint,
                        capacity: cell.capacity,
                    });
                }
            });
        }
    });
    return leftCells;
};
exports.getLeftCells = getLeftCells;
const isFee = (fee) => typeof fee !== 'object';
const generateRawTransaction = (_a) => {
    var _b, _c;
    var { fee = '0x0', changeLockScript, safeMode = true, deps, capacityThreshold = MIN_CELL_CAPACITY, changeThreshold = MIN_CELL_CAPACITY } = _a, params = (0, tslib_1.__rest)(_a, ["fee", "changeLockScript", "safeMode", "deps", "capacityThreshold", "changeThreshold"]);
    if (!deps) {
        throw new Error('The dep is not loaded');
    }
    const { targetFee, minCapacity, minChange, zeroBigInt } = (0, exports.getBigInts)({
        fee: isFee(fee) ? fee : '0x0',
        capacityThreshold,
        changeThreshold,
    });
    const { inputScripts, outputs: toOutputs, unspentCellsMap } = (0, exports.getKeyAndCellsPairs)(params);
    const targetOutputs = (0, exports.getTargetOutputs)({ outputs: toOutputs, minCapacity });
    const targetCapacity = targetOutputs.reduce((acc, o) => ckb_sdk_utils_1.JSBI.add(acc, o.capacity), zeroBigInt);
    const costCapacity = ckb_sdk_utils_1.JSBI.add(ckb_sdk_utils_1.JSBI.add(targetCapacity, targetFee), minChange);
    const changeOutput = {
        capacity: zeroBigInt,
        lock: changeLockScript || inputScripts[0],
    };
    const { inputs, sum: inputSum } = (0, exports.getInputs)({ inputScripts, safeMode, costCapacity, unspentCellsMap });
    if (ckb_sdk_utils_1.JSBI.greaterThan(inputSum, ckb_sdk_utils_1.JSBI.add(targetCapacity, targetFee))) {
        changeOutput.capacity = ckb_sdk_utils_1.JSBI.subtract(ckb_sdk_utils_1.JSBI.subtract(inputSum, targetCapacity), targetFee);
    }
    const outputs = targetOutputs.map(o => (Object.assign(Object.assign({}, o), { capacity: `0x${o.capacity.toString(16)}` })));
    if (ckb_sdk_utils_1.JSBI.greaterThan(changeOutput.capacity, zeroBigInt)) {
        outputs.push(Object.assign(Object.assign({}, changeOutput), { capacity: `0x${changeOutput.capacity.toString(16)}` }));
    }
    const cellDeps = Array.isArray(deps) ? deps : [deps];
    const witnesses = (_b = params.witnesses) !== null && _b !== void 0 ? _b : [];
    inputs.forEach((input, idx) => {
        var _a;
        if (!witnesses[idx]) {
            witnesses[idx] = input.lockhash !== ((_a = inputs[idx - 1]) === null || _a === void 0 ? void 0 : _a.lockhash) ? const_1.EMPTY_WITNESS_ARGS : '0x';
        }
    });
    const outputsData = (_c = params.outputsData) !== null && _c !== void 0 ? _c : [];
    outputs.forEach((_, idx) => {
        if (!outputsData[idx]) {
            outputsData[idx] = '0x';
        }
    });
    const tx = {
        version: '0x0',
        cellDeps: cellDeps.map(dep => ({ outPoint: dep.outPoint, depType: dep.depType })),
        headerDeps: [],
        inputs: inputs.map(({ previousOutput, since }) => ({ previousOutput, since })),
        outputs,
        witnesses,
        outputsData,
    };
    if (!isFee(fee)) {
        const leftCells = (0, exports.getLeftCells)({ inputScripts, usedCells: tx.inputs, unspentCellsMap });
        return fee.reconciler({ tx, feeRate: fee.feeRate, changeThreshold, cells: leftCells, extraCount: 10 });
    }
    return tx;
};
exports.default = generateRawTransaction;
//# sourceMappingURL=generateRawTransaction.js.map