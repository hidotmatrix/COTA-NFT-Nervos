"use strict";
var _CKB_secp256k1DepsShouldBeReady, _CKB_DAODepsShouldBeReady, _CKB_validateTransactionToSign, _CKB_isSimpleTransaction, _CKB_isComplexTransaction, _CKB_setSecp256k1Dep, _CKB_setDaoDep;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ckb_sdk_rpc_1 = (0, tslib_1.__importDefault)(require("@nervosnetwork/ckb-sdk-rpc"));
const exceptions_1 = require("@nervosnetwork/ckb-sdk-utils/lib/exceptions");
const utils = (0, tslib_1.__importStar)(require("@nervosnetwork/ckb-sdk-utils"));
const generateRawTransaction_1 = (0, tslib_1.__importDefault)(require("./generateRawTransaction"));
const loadCellsFromIndexer_1 = (0, tslib_1.__importDefault)(require("./loadCellsFromIndexer"));
const signWitnesses_1 = (0, tslib_1.__importStar)(require("./signWitnesses"));
const utils_1 = require("./utils");
class CKB {
    constructor(nodeUrl = 'http://localhost:8114') {
        this.cells = new Map();
        this.utils = utils;
        this.config = {};
        this.generateLockHash = (args, dep = this.config.secp256k1Dep) => {
            if (!dep) {
                throw new exceptions_1.ParameterRequiredException('deps');
            }
            return this.utils.scriptToHash(Object.assign(Object.assign({}, dep), { args }));
        };
        this.loadDeps = () => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const genesisBlock = yield this.rpc.getBlockByNumber('0x0');
            if (!genesisBlock) {
                throw new Error('Fail to load the genesis block');
            }
            (0, tslib_1.__classPrivateFieldGet)(this, _CKB_setDaoDep, "f").call(this, genesisBlock);
            (0, tslib_1.__classPrivateFieldGet)(this, _CKB_setSecp256k1Dep, "f").call(this, genesisBlock);
            return this.config;
        });
        this.loadCells = (params) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const lockHash = this.utils.scriptToHash(params.lock);
            const cells = yield (0, loadCellsFromIndexer_1.default)(params);
            if (params.save) {
                this.cells.set(lockHash, cells);
            }
            return cells;
        });
        this.signWitnesses = signWitnesses_1.default;
        this.signTransaction = (key) => (transaction, cells = []) => {
            if (!key)
                throw new exceptions_1.ParameterRequiredException('Private key or address object');
            (0, tslib_1.__classPrivateFieldGet)(this, _CKB_validateTransactionToSign, "f").call(this, transaction);
            const transactionHash = this.utils.rawTransactionToHash(transaction);
            const inputCells = (0, signWitnesses_1.isMap)(key) ? (0, utils_1.filterCellsByInputs)(cells, transaction.inputs) : undefined;
            const signedWitnesses = this.signWitnesses(key)({
                transactionHash,
                witnesses: transaction.witnesses,
                inputCells,
            });
            return Object.assign(Object.assign({}, transaction), { witnesses: signedWitnesses.map(witness => typeof witness === 'string' ? witness : this.utils.serializeWitnessArgs(witness)) });
        };
        this.generateRawTransaction = (_a) => {
            var _b;
            var { fee, safeMode = true, deps, capacityThreshold, changeThreshold, witnesses, outputsData } = _a, params = (0, tslib_1.__rest)(_a, ["fee", "safeMode", "deps", "capacityThreshold", "changeThreshold", "witnesses", "outputsData"]);
            if ((0, tslib_1.__classPrivateFieldGet)(this, _CKB_isSimpleTransaction, "f").call(this, params)) {
                const [inputScript, outputScript] = [params.fromAddress, params.toAddress].map(this.utils.addressToScript);
                let availableCells = params.cells || [];
                if (!availableCells.length) {
                    availableCells = (_b = this.cells.get(this.utils.scriptToHash(inputScript))) !== null && _b !== void 0 ? _b : availableCells;
                }
                return (0, generateRawTransaction_1.default)({
                    inputScript,
                    outputScript,
                    capacity: params.capacity,
                    fee,
                    safeMode,
                    cells: availableCells,
                    deps,
                    capacityThreshold,
                    changeThreshold,
                    witnesses,
                    outputsData,
                });
            }
            if ((0, tslib_1.__classPrivateFieldGet)(this, _CKB_isComplexTransaction, "f").call(this, params)) {
                const inputScripts = params.fromAddresses.map(this.utils.addressToScript);
                const outputs = params.receivePairs.map(pair => ({
                    lock: this.utils.addressToScript(pair.address),
                    capacity: pair.capacity,
                    type: pair.type,
                }));
                return (0, generateRawTransaction_1.default)({
                    inputScripts,
                    outputs,
                    cells: params.cells || this.cells,
                    fee,
                    safeMode,
                    deps,
                    capacityThreshold,
                    changeThreshold,
                    witnesses,
                    outputsData,
                });
            }
            throw new Error('Parameters of generateRawTransaction are invalid');
        };
        this.generateDaoDepositTransaction = ({ fromAddress, capacity, fee, cells = [], }) => {
            (0, tslib_1.__classPrivateFieldGet)(this, _CKB_secp256k1DepsShouldBeReady, "f").call(this);
            (0, tslib_1.__classPrivateFieldGet)(this, _CKB_DAODepsShouldBeReady, "f").call(this);
            const rawTx = this.generateRawTransaction({
                fromAddress,
                toAddress: fromAddress,
                capacity,
                fee,
                safeMode: true,
                cells,
                deps: [this.config.secp256k1Dep, this.config.daoDep],
            });
            rawTx.outputs[0].type = {
                codeHash: this.config.daoDep.typeHash,
                args: '0x',
                hashType: this.config.daoDep.hashType,
            };
            rawTx.outputsData[0] = '0x0000000000000000';
            return rawTx;
        };
        this.generateDaoWithdrawStartTransaction = ({ outPoint, fee, cells = [], }) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            (0, tslib_1.__classPrivateFieldGet)(this, _CKB_secp256k1DepsShouldBeReady, "f").call(this);
            (0, tslib_1.__classPrivateFieldGet)(this, _CKB_DAODepsShouldBeReady, "f").call(this);
            const cellStatus = yield this.rpc.getLiveCell(outPoint, false);
            if (cellStatus.status !== 'live')
                throw new Error('Cell is not live yet.');
            const tx = yield this.rpc.getTransaction(outPoint.txHash);
            if (tx.txStatus.status !== 'committed')
                throw new Error('Transaction is not committed yet');
            const depositBlockHeader = yield this.rpc.getBlock(tx.txStatus.blockHash).then(b => b.header);
            const encodedBlockNumber = this.utils.toUint64Le(depositBlockHeader.number);
            const fromAddress = this.utils.bech32Address(cellStatus.cell.output.lock.args);
            const rawTx = this.generateRawTransaction({
                fromAddress,
                toAddress: fromAddress,
                capacity: '0x0',
                fee,
                safeMode: true,
                deps: [this.config.secp256k1Dep, this.config.daoDep],
                capacityThreshold: '0x0',
                cells,
            });
            rawTx.outputs[0] = tx.transaction.outputs[+outPoint.index];
            rawTx.outputsData[0] = encodedBlockNumber;
            rawTx.inputs.unshift({ previousOutput: outPoint, since: '0x0' });
            rawTx.headerDeps.push(depositBlockHeader.hash);
            return rawTx;
        });
        this.generateDaoWithdrawTransaction = ({ depositOutPoint, withdrawOutPoint, fee, }) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            var _a, _b;
            (0, tslib_1.__classPrivateFieldGet)(this, _CKB_secp256k1DepsShouldBeReady, "f").call(this);
            (0, tslib_1.__classPrivateFieldGet)(this, _CKB_DAODepsShouldBeReady, "f").call(this);
            const { JSBI } = this.utils;
            const cellStatus = yield this.rpc.getLiveCell(withdrawOutPoint, true);
            if (cellStatus.status !== 'live')
                throw new Error('Cell is not live yet');
            const tx = yield this.rpc.getTransaction(withdrawOutPoint.txHash);
            if (tx.txStatus.status !== 'committed')
                throw new Error('Transaction is not committed yet');
            const depositBlockNumber = this.utils.bytesToHex(this.utils.hexToBytes((_b = (_a = cellStatus.cell.data) === null || _a === void 0 ? void 0 : _a.content) !== null && _b !== void 0 ? _b : '').reverse());
            const depositBlockHeader = yield this.rpc.getBlockByNumber(BigInt(depositBlockNumber)).then(block => block.header);
            const withdrawStartBlockHeader = yield this.rpc.getBlock(tx.txStatus.blockHash).then(block => block.header);
            const withdrawEndEpoch = this.utils.getWithdrawEpoch(depositBlockHeader.epoch, withdrawStartBlockHeader.epoch);
            const outputCapacity = yield this.rpc.calculateDaoMaximumWithdraw(depositOutPoint, withdrawStartBlockHeader.hash);
            const targetCapacity = JSBI.BigInt(outputCapacity);
            const targetFee = JSBI.BigInt(`${fee}`);
            if (JSBI.lessThan(targetCapacity, targetFee)) {
                throw new Error(`The fee(${targetFee}) is too big that withdraw(${targetCapacity}) is not enough`);
            }
            const outputs = [
                {
                    capacity: `0x${JSBI.subtract(targetCapacity, targetFee).toString(16)}`,
                    lock: tx.transaction.outputs[+withdrawOutPoint.index].lock,
                },
            ];
            const outputsData = ['0x'];
            return {
                version: '0x0',
                cellDeps: [
                    { outPoint: this.config.secp256k1Dep.outPoint, depType: this.config.secp256k1Dep.depType },
                    { outPoint: this.config.daoDep.outPoint, depType: this.config.daoDep.depType },
                ],
                headerDeps: [depositBlockHeader.hash, withdrawStartBlockHeader.hash],
                inputs: [
                    {
                        previousOutput: withdrawOutPoint,
                        since: withdrawEndEpoch,
                    },
                ],
                outputs,
                outputsData,
                witnesses: [
                    {
                        lock: '',
                        inputType: '0x0000000000000000',
                        outputType: '',
                    },
                ],
            };
        });
        this.calculateDaoMaximumWithdraw = (depositOutPoint, withdraw) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            let tx = yield this.rpc.getTransaction(depositOutPoint.txHash);
            if (tx.txStatus.status !== 'committed')
                throw new Error('Transaction is not committed yet');
            const depositBlockHash = tx.txStatus.blockHash;
            let celloutput = tx.transaction.outputs[+depositOutPoint.index];
            let celloutputData = tx.transaction.outputsData[+depositOutPoint.index];
            let withdrawBlockHash;
            if (typeof withdraw === 'string') {
                withdrawBlockHash = withdraw;
            }
            else {
                tx = yield this.rpc.getTransaction(withdraw.txHash);
                if (tx.txStatus.status !== 'committed')
                    throw new Error('Transaction is not committed yet');
                withdrawBlockHash = tx.txStatus.blockHash;
                celloutput = tx.transaction.outputs[+withdraw.index];
                celloutputData = tx.transaction.outputsData[+withdraw.index];
            }
            const [depositHeader, withDrawHeader] = yield Promise.all([
                this.rpc.getHeader(depositBlockHash),
                this.rpc.getHeader(withdrawBlockHash)
            ]);
            return utils.calculateMaximumWithdraw(celloutput, celloutputData, depositHeader.dao, withDrawHeader.dao);
        });
        _CKB_secp256k1DepsShouldBeReady.set(this, () => {
            if (!this.config.secp256k1Dep) {
                throw new exceptions_1.ParameterRequiredException('Secp256k1 dep');
            }
        });
        _CKB_DAODepsShouldBeReady.set(this, () => {
            if (!this.config.daoDep) {
                throw new exceptions_1.ParameterRequiredException('Dao dep');
            }
        });
        _CKB_validateTransactionToSign.set(this, (transaction) => {
            if (!transaction)
                throw new exceptions_1.ParameterRequiredException('Transaction');
            if (!transaction.witnesses)
                throw new exceptions_1.ParameterRequiredException('Witnesses');
            if (!transaction.outputsData)
                throw new exceptions_1.ParameterRequiredException('OutputsData');
            if (transaction.outputsData.length < transaction.outputs.length)
                throw new Error('Invalid count of outputsData');
        });
        _CKB_isSimpleTransaction.set(this, (params) => {
            return 'fromAddress' in params && 'toAddress' in params;
        });
        _CKB_isComplexTransaction.set(this, (params) => {
            return 'fromAddresses' in params && 'receivePairs' in params;
        });
        _CKB_setSecp256k1Dep.set(this, (genesisBlock) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            var _c, _d;
            const secp256k1DepTxHash = genesisBlock === null || genesisBlock === void 0 ? void 0 : genesisBlock.transactions[1].hash;
            const typeScript = (_d = (_c = genesisBlock === null || genesisBlock === void 0 ? void 0 : genesisBlock.transactions[0]) === null || _c === void 0 ? void 0 : _c.outputs[1]) === null || _d === void 0 ? void 0 : _d.type;
            const secp256k1TypeHash = this.utils.scriptToHash(typeScript);
            this.config.secp256k1Dep = {
                hashType: 'type',
                codeHash: secp256k1TypeHash,
                outPoint: {
                    txHash: secp256k1DepTxHash,
                    index: '0x0',
                },
                depType: 'depGroup',
            };
        }));
        _CKB_setDaoDep.set(this, (genesisBlock) => {
            var _a, _b, _c;
            const daoDepTxHash = genesisBlock === null || genesisBlock === void 0 ? void 0 : genesisBlock.transactions[0].hash;
            const typeScript = (_b = (_a = genesisBlock === null || genesisBlock === void 0 ? void 0 : genesisBlock.transactions[0]) === null || _a === void 0 ? void 0 : _a.outputs[2]) === null || _b === void 0 ? void 0 : _b.type;
            const data = (_c = genesisBlock === null || genesisBlock === void 0 ? void 0 : genesisBlock.transactions[0]) === null || _c === void 0 ? void 0 : _c.outputsData[2];
            const typeHash = this.utils.scriptToHash(typeScript);
            const s = utils.blake2b(32, null, null, utils.PERSONAL);
            s.update(utils.hexToBytes(data));
            const codeHash = `0x${s.digest('hex')}`;
            this.config.daoDep = {
                hashType: 'type',
                codeHash,
                typeHash,
                outPoint: {
                    txHash: daoDepTxHash,
                    index: '0x2',
                },
                depType: 'code',
            };
        });
        this._node = {
            url: nodeUrl,
        };
        this.rpc = new ckb_sdk_rpc_1.default(nodeUrl);
    }
    setNode(node) {
        if (typeof node === 'string') {
            this._node.url = node;
        }
        else {
            this._node = node;
        }
        this.rpc.setNode(this._node);
        return this._node;
    }
    get node() {
        return this._node;
    }
}
_CKB_secp256k1DepsShouldBeReady = new WeakMap(), _CKB_DAODepsShouldBeReady = new WeakMap(), _CKB_validateTransactionToSign = new WeakMap(), _CKB_isSimpleTransaction = new WeakMap(), _CKB_isComplexTransaction = new WeakMap(), _CKB_setSecp256k1Dep = new WeakMap(), _CKB_setDaoDep = new WeakMap();
exports.default = CKB;
//# sourceMappingURL=index.js.map