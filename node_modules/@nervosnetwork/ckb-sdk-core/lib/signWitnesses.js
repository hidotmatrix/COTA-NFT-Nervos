"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMap = void 0;
const tslib_1 = require("tslib");
const exceptions_1 = require("@nervosnetwork/ckb-sdk-utils/lib/exceptions");
const signWitnessGroup_1 = (0, tslib_1.__importDefault)(require("./signWitnessGroup"));
const groupScripts_1 = (0, tslib_1.__importDefault)(require("./groupScripts"));
const isMap = (val) => {
    return val.size !== undefined;
};
exports.isMap = isMap;
const signWitnesses = (key) => ({ transactionHash, witnesses = [], inputCells = [], skipMissingKeys = false, }) => {
    if (!key)
        throw new exceptions_1.ParameterRequiredException('Signature provider');
    if (!transactionHash)
        throw new exceptions_1.ParameterRequiredException('Transaction hash');
    if (!witnesses.length)
        throw new Error('Witnesses is empty');
    if ((0, exports.isMap)(key)) {
        const rawWitnesses = witnesses;
        const restWitnesses = witnesses.slice(inputCells.length);
        const groupedScripts = (0, groupScripts_1.default)(inputCells);
        groupedScripts.forEach((indices, lockhash) => {
            const sk = key.get(lockhash);
            if (!sk) {
                if (!skipMissingKeys) {
                    throw new Error(`The signature provider to sign lockhash ${lockhash} is not found`);
                }
                else {
                    return;
                }
            }
            const ws = [...indices.map(idx => witnesses[idx]), ...restWitnesses];
            const witnessIncludeSignature = (0, signWitnessGroup_1.default)(sk, transactionHash, ws)[0];
            rawWitnesses[indices[0]] = witnessIncludeSignature;
        });
        return rawWitnesses;
    }
    const signedWitnesses = (0, signWitnessGroup_1.default)(key, transactionHash, witnesses);
    return signedWitnesses;
};
exports.default = signWitnesses;
//# sourceMappingURL=signWitnesses.js.map