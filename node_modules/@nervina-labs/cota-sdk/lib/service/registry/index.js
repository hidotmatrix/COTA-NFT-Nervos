"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRegisterCotaTx = void 0;
const ckb_sdk_utils_1 = require("@nervosnetwork/ckb-sdk-utils");
const constants_1 = require("../../constants");
const hex_1 = require("../../utils/hex");
const COTA_CELL_CAPACITY = BigInt(150) * BigInt(100000000);
const generateCotaOutputs = (inputCapacity, cotaLocks, changeLock, fee, isMainnet) => __awaiter(void 0, void 0, void 0, function* () {
    let outputs = cotaLocks.map(lock => {
        const args = (0, hex_1.append0x)((0, hex_1.remove0x)((0, ckb_sdk_utils_1.scriptToHash)(lock)).slice(0, 40));
        const cotaType = Object.assign(Object.assign({}, (0, constants_1.getCotaTypeScript)(isMainnet)), { args });
        return {
            capacity: `0x${COTA_CELL_CAPACITY.toString(16)}`,
            lock,
            type: cotaType,
        };
    });
    const cotaCellsLength = BigInt(cotaLocks.length);
    const changeCapacity = inputCapacity - fee - COTA_CELL_CAPACITY * cotaCellsLength;
    outputs.push({
        capacity: `0x${changeCapacity.toString(16)}`,
        lock: changeLock,
        type: null,
    });
    return outputs;
});
const generateRegisterCotaTx = (service, cotaLocks, lock, fee = constants_1.FEE, isMainnet = false) => __awaiter(void 0, void 0, void 0, function* () {
    const cotaCount = BigInt(cotaLocks.length);
    const registryLock = (0, constants_1.getAlwaysSuccessLock)(isMainnet);
    const registryType = (0, constants_1.getRegistryTypeScript)(isMainnet);
    const registryCells = yield service.collector.getCells(registryLock, registryType);
    if (!registryCells || registryCells.length === 0) {
        throw new Error("Registry cell doesn't exist");
    }
    let registryCell = registryCells[0];
    const liveCells = yield service.collector.getCells(lock);
    const { inputs: normalInputs, capacity } = yield service.collector.collectInputs(liveCells, COTA_CELL_CAPACITY * cotaCount, fee);
    let inputs = [
        {
            previousOutput: registryCell.outPoint,
            since: '0x0',
        },
    ];
    inputs = inputs.concat(normalInputs);
    let outputs = yield generateCotaOutputs(capacity, cotaLocks, lock, fee, isMainnet);
    outputs = [registryCell.output].concat(outputs);
    const length = outputs.length;
    outputs[length - 1].capacity = `0x${(BigInt(outputs[length - 1].capacity) - fee).toString(16)}`;
    const lockHashes = cotaLocks.map(lock => (0, ckb_sdk_utils_1.scriptToHash)(lock));
    const { smtRootHash, registrySmtEntry } = yield service.aggregator.generateRegisterCotaSmt(lockHashes);
    const registryCellData = `0x02${smtRootHash}`;
    const outputsData = outputs.map((_, i) => i === 0 ? registryCellData : i !== outputs.length - 1 ? `0x02${'00'.repeat(32)}` : '0x');
    const cellDeps = [(0, constants_1.getAlwaysSuccessCellDep)(isMainnet), (0, constants_1.getCotaCellDep)(isMainnet)];
    let rawTx = {
        version: '0x0',
        cellDeps,
        headerDeps: [],
        inputs,
        outputs,
        outputsData,
        witnesses: [],
    };
    const registryWitness = (0, ckb_sdk_utils_1.serializeWitnessArgs)({ lock: '', inputType: (0, hex_1.append0x)(registrySmtEntry), outputType: '' });
    const emptyWitness = { lock: '', inputType: '', outputType: '' };
    rawTx.witnesses = rawTx.inputs.map((_, i) => (i === 0 ? registryWitness : i === 1 ? emptyWitness : '0x'));
    return rawTx;
});
exports.generateRegisterCotaTx = generateRegisterCotaTx;
