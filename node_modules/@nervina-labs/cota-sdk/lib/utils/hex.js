"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexToUtf8 = exports.utf8ToHex = exports.u64ToBe = exports.u64ToLe = exports.hexToU8 = exports.u8ToHex = exports.u32ToLe = exports.u32ToBe = exports.u16ToBe = exports.append0x = exports.remove0x = void 0;
const ckb_sdk_utils_1 = require("@nervosnetwork/ckb-sdk-utils");
const remove0x = (hex) => {
    if (hex.startsWith('0x')) {
        return hex.substring(2);
    }
    return hex;
};
exports.remove0x = remove0x;
const append0x = (hex) => {
    return (hex === null || hex === void 0 ? void 0 : hex.startsWith('0x')) ? hex : `0x${hex}`;
};
exports.append0x = append0x;
const ArrayBufferToHex = (arrayBuffer) => {
    return Array.prototype.map.call(new Uint8Array(arrayBuffer), x => ('00' + x.toString(16)).slice(-2)).join('');
};
const u16ToBe = (u16) => {
    let buffer = new ArrayBuffer(2);
    let view = new DataView(buffer);
    view.setUint16(0, u16, false);
    return ArrayBufferToHex(buffer);
};
exports.u16ToBe = u16ToBe;
const u32ToHex = (u32, littleEndian) => {
    let buffer = new ArrayBuffer(4);
    let view = new DataView(buffer);
    view.setUint32(0, Number(u32), littleEndian);
    return ArrayBufferToHex(buffer);
};
const u32ToBe = (u32) => {
    return u32ToHex(u32, false);
};
exports.u32ToBe = u32ToBe;
const u32ToLe = (u32) => {
    return u32ToHex(u32, true);
};
exports.u32ToLe = u32ToLe;
const u8ToHex = (u8) => {
    let buffer = new ArrayBuffer(1);
    let view = new DataView(buffer);
    view.setUint8(0, u8);
    return ArrayBufferToHex(buffer);
};
exports.u8ToHex = u8ToHex;
const hexToU8 = (hex) => {
    const tmp = (0, exports.remove0x)(hex);
    if (tmp.length !== 2) {
        throw new Error('The hex format length of u8 must be equal to 2');
    }
    return parseInt(tmp, 16);
};
exports.hexToU8 = hexToU8;
const u64ToLe = (u64) => {
    if (typeof u64 !== 'bigint') {
        throw new Error('u64 must be bigint');
    }
    const val = u64.toString(16).padStart(16, '0');
    const viewRight = (0, exports.u32ToLe)(`0x${val.slice(0, 8)}`);
    const viewLeft = (0, exports.u32ToLe)(`0x${val.slice(8)}`);
    return `${viewLeft}${viewRight}`;
};
exports.u64ToLe = u64ToLe;
const u64ToBe = (u64) => {
    if (typeof u64 !== 'bigint') {
        throw new Error('u64 must be bigint');
    }
    const val = u64.toString(16).padStart(16, '0');
    const viewLeft = (0, exports.u32ToBe)(`0x${val.slice(0, 8)}`);
    const viewRight = (0, exports.u32ToBe)(`0x${val.slice(8)}`);
    return `${viewLeft}${viewRight}`;
};
exports.u64ToBe = u64ToBe;
const utf8ToHex = (text) => {
    let result = text.trim();
    if (result.startsWith('0x')) {
        return result;
    }
    result = (0, ckb_sdk_utils_1.bytesToHex)(new TextEncoder().encode(result));
    return result;
};
exports.utf8ToHex = utf8ToHex;
const hexToUtf8 = (hex) => {
    let result = hex.trim();
    try {
        result = new TextDecoder().decode((0, ckb_sdk_utils_1.hexToBytes)(result));
    }
    catch (error) {
        console.error('hexToUtf8 error:', error);
    }
    return result;
};
exports.hexToUtf8 = hexToUtf8;
